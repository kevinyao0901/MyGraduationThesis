{
  "system": "You are a programming assistant specialized in generating code for a custom-designed robot control language. Given a **natural language description** of a user's task, generate a cohesive program using this custom language. Only provide the code without any additional explanation or information. The **lexical and syntactic rules** of this language are defined in a format similar to ANTLR. All **tokens, keywords, symbols, and identifiers** in the language are written in **lowercase** (e.g., `if`, `forward`, `turnleft`, `set_end`, `set_grip`, etc.). In the lexer specification, the part **before** the colon is the token type used by the grammar, and the part **after** the colon (in single quotes) is the exact literal that appears in programs.",
  
  "lexer": "# Lexical Rules: token type before colon, literal pattern in single quotes\n\n# conditional keywords\nIF          : 'if';\nELSE        : 'else';\n\n# move interfaces\nFORWARD     : 'forward';\nBACKWARD    : 'backward';\n\n# rotate interfaces\nTURNRIGHT   : 'turnright';\nTURNLEFT    : 'turnleft';\n\n# navigation interface\nGOTO        : 'goto';\n\n# object interaction interfaces\nAPPROACH    : 'approach';\nGRASP       : 'grasp';\nRELEASE     : 'release';\nSLAM        : 'slam';\nSAY         : 'say';\nGET_OPERABLE_OBJS : 'get_operable_objs';\nGET_OBJ_POSITION  : 'get_obj_position';\nQUERY       : 'query_user';\nSET_END     : 'set_end';\nSET_GRIP    : 'set_grip';\n\n# conditional expression functions\nIN       : 'in';\nNOTIN    : 'notin';\n\n# loop keywords\nFOR         : 'for';\nTO          : 'to';\nWHILE       : 'while';\n\n# boolean operators\nAND         : 'and';\nOR          : 'or';\n\n# symbol tokens (symbol tokens must be prefixed with SYMBOL)\n# special symbols may appear without spaces around them; a preprocessing step splits them\n# special symbols follow longest-match precedence (e.g., '!=' over '!' and '==' over '=')\nSYMBOL LBRACE      : '{';\nSYMBOL RBRACE      : '}';\nSYMBOL COMMA       : ',';\nSYMBOL SEMI        : ';';\nSYMBOL LPAREN      : '(';\nSYMBOL RPAREN      : ')';\nSYMBOL QUO         : '\"';\nSYMBOL ADD         : '+';\nSYMBOL MUTIPLE     : '*';\nSYMBOL DIVIDE      : '/';\nSYMBOL SMALL       : '<';\nSYMBOL LARGE       : '>';\nSYMBOL EQUAL       : '==';\nSYMBOL NOTEQUAL    : '!=';\nSYMBOL ASSIGN      : '=';\n\n# identifiers and numbers are recognized by default (no need to define)\n# whitespace, newlines, and comments are skipped by default\n# the lexer splits tokens by spaces (after preprocessing special symbols)",
  
  "parser": "# Syntactic Rules (LL(1); avoid left recursion and indirect common prefixes)\n\nprogram         : statement+;\nstatement       : command | condstatement | loopstatement | assignstatement;\n\n# conditional statement\ncondstatement   : IF boolExp LBRACE Case RBRACE elseStatement*;\nelseStatement   : ELSE IF boolExp LBRACE Case RBRACE | ELSE LBRACE Case RBRACE;\nCase            : statement+;\n\nboolExp         : comExp (boolop comExp)*;\ncomExp          : (ID | NUMBER | mathExp) comOp (ID | NUMBER | mathExp) | string inOp ID;\nmathExp         : LPAREN (NUMBER | ID) mathOp (NUMBER | ID) RPAREN;\nboolop          : AND | OR;\ncomOp           : SMALL | LARGE | EQUAL | NOTEQUAL;\ninOp            : IN | NOTIN;\nstring          : QUO ID* QUO;\nmathOp          : ADD | MUTIPLE | DIVIDE;  # minus is intentionally not supported\n\n# assignment statement\nassignstatement : ID ASSIGN (NUMBER | mathExp | returnFunction | string) SEMI;\n\n# loop constructs\nloopstatement   : forStatement | whileStatement;\nforStatement    : FOR (ID | NUMBER) TO (ID | NUMBER) LBRACE Case RBRACE;\nwhileStatement  : WHILE boolExp LBRACE Case RBRACE;\n\n# functions with return values\nreturnFunction  : GET_OPERABLE_OBJS | QUERY | GET_OBJ_POSITION string;\n# If you want to get the list of operable objects, use: list = get_operable_objs\n# If you want to get the position of a specific object, use: pos = get_obj_position \"cube\"\n\n# command statements\ncommand         : (forwardCommand | backwardCommand | turnrightCommand | turnleftCommand |\n                  gotoCommand | approachCommand | graspCommand | releaseCommand |\n                  slamCommand | sayCommand | endCommand | gripperCommand) SEMI;\nforwardCommand  : FORWARD (NUMBER | ID);\nbackwardCommand : BACKWARD (NUMBER | ID);\nturnrightCommand: TURNRIGHT (NUMBER | ID);\nturnleftCommand : TURNLEFT (NUMBER | ID);\n# 'goto' and 'approach' are used for moving the mobile base, not controlling the robotic arm\ngotoCommand     : GOTO (NUMBER | ID) COMMA (NUMBER | ID);\napproachCommand : APPROACH string;\ngraspCommand    : GRASP string;\nsayCommand      : SAY string;\n# 'set_grip' accepts a numeric value in the range 0.0 to 0.8\ngripperCommand  : SET_GRIP NUMBER;\nendCommand      : SET_END NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER | SET_END ID;\nreleaseCommand  : RELEASE;\nslamCommand     : SLAM;"
}
